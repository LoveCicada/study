
### C++ Interview Questions

- TOC

#### 1. 引用和指针的区别？
1. 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
2. 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：引用的值不能为`NULL`）
3. 有多级指针，但没有多级引用，只能有一级引用。
4. 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用是引用的变量值加1）
5. sizeof引用得到的是所指向的变量（对象）大小，而sizeof指针得到的是指针本身的大小。（32位程序，指针长度4字节；64位程序，指针长度8字节）
6. 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。
7. 使用指针最好做类型检查，防止野指针的出现。
8. 引用底层是通过指针实现的。
9. 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。

#### 2. 从汇编层去解释一下引用
```C++
1.9:          int x = 1;
2.00401048    mov         dword ptr [ebp-4],1
3.10:         int &b = x;
4.0040104F    lea         eax,[ebp-4]
5.00401052    mov         dword ptr [ebp-8],eax
```
x的地址


#### 3. C++中的指针参数传递和引用参数传递
1. 指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值。（形参指针变了，实参指针不会变）
2. 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。
3. 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。
4. 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变指向其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

#### 4. 形参和实参的区别？






#### 5. static的用法和作用？
1. 隐藏，（static函数，static变量均可）当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
2. static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static是用来隐藏的。
3. static变量默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。
4. C++中的类成员声明static。4.1 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；4.2 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问；4.3 在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内；4.4 在类中的static成员变量属于整个类所有，对类的所有对象只有一份拷贝；4.5 在类中的static成员函数属于整个类所有，这个函数不接收this指针，因而只能访问类的static成员变量；4.6 static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；4.7 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员；4.8 static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

#### 6. 静态变量什么时候初始化？
